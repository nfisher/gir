// Code generated by ragel DO NOT EDIT.
package gir

import "fmt"

%%{
  machine graphql_collections;

  include graphql_common "graphql_common.rl";

  # B3. Query Document

  # Document            =  Definition
  # Definition          = (OperationDefinition | FragmentDefinition)
  # OperationDefinition = (SelectionSet | OperationType Name VariableDefinitions Directives SelectionSet)
  # OperationType         = ('query' | 'mutation');

#  ListValues := |*
#            Variable      => { em.Emit(ts, te, Variable, data); };
#            IntValue      => { em.Emit(ts, te, IntValue, data); };
#            FloatValue    => { em.Emit(ts, te, FloatValue, data); };
#            StringValue   => { em.Emit(ts, te, StringValue, data); };
#            BooleanValue  => { em.Emit(ts, te, BooleanValue, data); };
#            NullValue     => { em.Emit(ts, te, NullValue, data); };
#            EnumValue     => { em.Emit(ts, te, EnumValue, data); };
#            Ignored       => { /* Ignore */ };
#            '{'           => { fcall ObjectValues; };
#            '['           => { fcall ListValues; };
#            ']'           => { fret; };
#          *|;

  ObjectValues := |*
            Variable      => { em.Emit(ts, te, Variable, data); };
            IntValue      => { em.Emit(ts, te, IntValue, data); };
            FloatValue    => { em.Emit(ts, te, FloatValue, data); };
            StringValue   => { em.Emit(ts, te, StringValue, data); };
            BooleanValue  => { em.Emit(ts, te, BooleanValue, data); };
            NullValue     => { em.Emit(ts, te, NullValue, data); };
            EnumValue     => { em.Emit(ts, te, EnumValue, data); };
            Ignored       => { /* Ignore */ };
            '{'           => { fcall ObjectValues; };
#            '['           => { fcall ListValues; };
            '}'           => { fret; };
          *|;

  main := (
          ObjectStart @{ fcall ObjectValues; }
#          ListStart   > { fcall ListValues; } |
          )*;
}%%

%%{

prepush {
  c := cap(stack)
  l := len(stack)
  if stack == nil || l == c {
    tmp := make([]int, l, c * 2)
    copy(tmp, stack)
    stack = tmp
  }
  stack = append(stack, 0)
}

postpop {
  fmt.Printf("Pop!\n")
  stack = stack[0:len(stack)-1]
}

}%%

%% write data nofinal;

func ParseQuery(data []byte, em Emitter) {
  var token Token
  var stack []int
  cs, p, pe, eof := 0, 0, len(data), len(data)
  ts, te, act, top := 0, 0, 0, 0
  _ = eof
  _ = act
  _ = token
  _ = stack
  _ = top

  %% write init;

  %% write exec;
}
