// Code generated by ragel DO NOT EDIT.
package gir

import "errors"

%%{
  machine graphql_values;

  include graphql_common "graphql_common.rl";

prepush {
  fmt.Printf("Push!\n")
  if stack == nil || len(stack) == cap(stack) {
    new_stack := make([]int, len(stack), cap(stack)*2)
    copy(new_stack, stack)
    stack = new_stack
  }
  stack = append(stack, 0)
}

postpop {
  fmt.Printf("Pop!\n")
  stack = stack[0:len(stack)-1]
}

# Create a scanner
main := |*
					Variable      => { em.Emit(ts, te, Variable, data); };
					IntValue      => { em.Emit(ts, te, IntValue, data); };
					FloatValue    => { em.Emit(ts, te, FloatValue, data); };
					StringValue   => { em.Emit(ts, te, StringValue, data); };
					BooleanValue  => { em.Emit(ts, te, BooleanValue, data); };
					NullValue     => { em.Emit(ts, te, NullValue, data); };
					EnumValue     => { em.Emit(ts, te, EnumValue, data); };
					Ignored       => { /* Ignore */ };
				*|;
}%%

%% write data nofinal;

var ErrParse = errors.New("parse error")

func ParseValues(data []byte, em Emitter) error {
  var stack []int
  var token Token
  cs, p, pe, eof := 0, 0, len(data), len(data)
  ts, te, act, top := 0, 0, 0, 0
  _ = eof
  _ = act
  _ = token
  _ = top
  _ = stack

  %% write init;

  %% write exec;

  if ( cs < %%{ write first_final; }%% ) {
    return ErrParse
  }

  return nil
}
